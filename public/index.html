<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HLP Deposit Timing Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
  :root {
    --bg: #0a0e17;
    --card: #111827;
    --border: #1e293b;
    --text: #e2e8f0;
    --muted: #64748b;
    --green: #22c55e;
    --red: #ef4444;
    --yellow: #eab308;
    --blue: #3b82f6;
    --purple: #a855f7;
    --cyan: #06b6d4;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 24px;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 24px;
    flex-wrap: wrap;
    gap: 16px;
  }

  .header h1 {
    font-size: 20px;
    font-weight: 700;
    letter-spacing: -0.5px;
  }

  .header h1 span { color: var(--muted); font-weight: 400; }

  .header-meta {
    display: flex;
    gap: 16px;
    align-items: center;
    font-size: 12px;
    color: var(--muted);
  }

  .live-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    display: inline-block;
    animation: pulse 2s infinite;
  }

  .live-dot.green { background: var(--green); }
  .live-dot.blue { background: var(--blue); }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .data-source {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  .data-source.db {
    background: rgba(59,130,246,0.15);
    color: var(--blue);
    border: 1px solid rgba(59,130,246,0.3);
  }

  .data-source.api {
    background: rgba(234,179,8,0.15);
    color: var(--yellow);
    border: 1px solid rgba(234,179,8,0.3);
  }

  /* Time Range Selector */
  .range-selector {
    display: flex;
    gap: 4px;
    margin-bottom: 24px;
    flex-wrap: wrap;
  }

  .range-btn {
    background: var(--card);
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 6px 14px;
    border-radius: 6px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .range-btn:hover { border-color: var(--blue); color: var(--text); }
  .range-btn.active {
    background: rgba(59,130,246,0.15);
    border-color: var(--blue);
    color: var(--blue);
  }

  /* Composite Signal */
  .composite-signal {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 28px 32px;
    margin-bottom: 24px;
    display: flex;
    align-items: center;
    gap: 32px;
    flex-wrap: wrap;
  }

  .signal-gauge {
    position: relative;
    width: 140px;
    height: 140px;
    flex-shrink: 0;
  }

  .signal-gauge svg { transform: rotate(-90deg); }

  .gauge-bg { stroke: var(--border); fill: none; stroke-width: 10; }
  .gauge-fill { fill: none; stroke-width: 10; stroke-linecap: round; transition: stroke-dashoffset 1s ease, stroke 0.5s ease; }

  .gauge-label {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
  }

  .gauge-score { font-size: 36px; font-weight: 800; line-height: 1; }
  .gauge-sublabel { font-size: 11px; color: var(--muted); margin-top: 4px; }

  .signal-details { flex: 1; min-width: 280px; }
  .signal-details h2 { font-size: 18px; margin-bottom: 4px; }
  .signal-verdict { font-size: 14px; margin-bottom: 16px; line-height: 1.5; }
  .signal-verdict strong { font-weight: 700; }

  .signal-bars { display: flex; flex-direction: column; gap: 8px; }

  .signal-bar-row {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 12px;
  }

  .signal-bar-label {
    width: 150px;
    flex-shrink: 0;
    color: var(--muted);
    text-align: right;
  }

  .signal-bar-track {
    flex: 1;
    height: 6px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
    max-width: 200px;
  }

  .signal-bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 1s ease;
  }

  .signal-bar-value {
    width: 32px;
    text-align: right;
    font-weight: 600;
    flex-shrink: 0;
  }

  /* Key Metrics Row */
  .metrics-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
  }

  .metric-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
  }

  .metric-label {
    font-size: 11px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
  }

  .metric-value {
    font-size: 22px;
    font-weight: 700;
    line-height: 1.2;
  }

  .metric-sub {
    font-size: 11px;
    color: var(--muted);
    margin-top: 4px;
  }

  .positive { color: var(--green); }
  .negative { color: var(--red); }
  .neutral { color: var(--yellow); }

  /* Chart Grid */
  .chart-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
    gap: 16px;
    margin-bottom: 24px;
  }

  .chart-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 20px;
  }

  .chart-card h3 {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .chart-wrap {
    position: relative;
    height: 240px;
  }

  /* Signal Detail Cards */
  .signal-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
  }

  .signal-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 20px;
  }

  .signal-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .signal-card-title {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted);
  }

  .signal-card-score {
    font-size: 20px;
    font-weight: 800;
  }

  .signal-card p {
    font-size: 13px;
    line-height: 1.6;
    color: var(--muted);
  }

  .signal-card .value-line {
    font-size: 14px;
    color: var(--text);
    margin-bottom: 8px;
    font-weight: 500;
  }

  /* Methodology */
  .methodology {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 24px;
    margin-bottom: 24px;
  }

  .methodology h3 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
  }

  .methodology p, .methodology li {
    font-size: 13px;
    line-height: 1.7;
    color: var(--muted);
  }

  .methodology ul { padding-left: 20px; margin-top: 8px; }
  .methodology li { margin-bottom: 4px; }

  /* Loading */
  .loading {
    text-align: center;
    padding: 80px 20px;
    color: var(--muted);
    font-size: 14px;
  }

  .loading .spinner {
    width: 32px; height: 32px;
    border: 3px solid var(--border);
    border-top-color: var(--blue);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .error-msg {
    background: rgba(239,68,68,0.1);
    border: 1px solid rgba(239,68,68,0.3);
    border-radius: 8px;
    padding: 16px;
    color: var(--red);
    font-size: 13px;
    margin-bottom: 16px;
  }

  @media (max-width: 600px) {
    body { padding: 12px; }
    .composite-signal { padding: 20px; gap: 20px; }
    .chart-grid { grid-template-columns: 1fr; }
    .signal-grid { grid-template-columns: 1fr; }
    .signal-bar-label { width: 100px; }
  }
</style>
</head>
<body>

<div class="header">
  <div>
    <h1>HLP Deposit Timing <span>/ Signal Dashboard</span></h1>
  </div>
  <div class="header-meta">
    <span id="data-source" class="data-source api"><span class="live-dot green"></span> Direct API</span>
    <span id="last-updated">Loading...</span>
  </div>
</div>

<!-- Time Range Selector -->
<div class="range-selector" id="range-selector" style="display:none;">
  <button class="range-btn" data-range="7d">7D</button>
  <button class="range-btn" data-range="30d">30D</button>
  <button class="range-btn" data-range="90d">90D</button>
  <button class="range-btn" data-range="1y">1Y</button>
  <button class="range-btn active" data-range="all">All</button>
</div>

<div id="loading" class="loading">
  <div class="spinner"></div>
  Fetching HLP vault data...
</div>

<div id="dashboard" style="display:none;">

  <!-- Composite Signal -->
  <div class="composite-signal">
    <div class="signal-gauge">
      <svg width="140" height="140" viewBox="0 0 140 140">
        <circle class="gauge-bg" cx="70" cy="70" r="60"/>
        <circle class="gauge-fill" id="gauge-circle" cx="70" cy="70" r="60"
          stroke-dasharray="377" stroke-dashoffset="377"/>
      </svg>
      <div class="gauge-label">
        <div class="gauge-score" id="composite-score">--</div>
        <div class="gauge-sublabel">/ 100</div>
      </div>
    </div>
    <div class="signal-details">
      <h2 id="verdict-title">Analyzing...</h2>
      <div class="signal-verdict" id="verdict-text"></div>
      <div class="signal-bars" id="signal-bars"></div>
    </div>
  </div>

  <!-- Key Metrics -->
  <div class="metrics-row" id="metrics-row"></div>

  <!-- Charts -->
  <div class="chart-grid">
    <div class="chart-card">
      <h3>NAV History &amp; Drawdown from ATH</h3>
      <div class="chart-wrap"><canvas id="chart-nav"></canvas></div>
    </div>
    <div class="chart-card">
      <h3>Daily Returns Distribution</h3>
      <div class="chart-wrap"><canvas id="chart-returns"></canvas></div>
    </div>
    <div class="chart-card">
      <h3>Cumulative PnL</h3>
      <div class="chart-wrap"><canvas id="chart-pnl"></canvas></div>
    </div>
    <div class="chart-card">
      <h3>Rolling 7-Day Return &amp; Volatility</h3>
      <div class="chart-wrap"><canvas id="chart-rolling"></canvas></div>
    </div>
  </div>

  <!-- Signal Detail Cards -->
  <div class="signal-grid" id="signal-cards"></div>

  <!-- Backtest Section -->
  <div class="chart-card" style="margin-bottom:24px;">
    <h3>Backtest: Forward Returns by Drawdown Level at Entry</h3>
    <p style="font-size:12px;color:var(--muted);margin-bottom:16px;">
      For each historical point, we measure the drawdown from ATH at that moment, then compute the forward return
      over the next N periods. Grouped by drawdown bucket, this shows whether entering after larger drawdowns
      has historically produced better risk-adjusted returns.
    </p>
    <div class="chart-wrap" style="height:300px;"><canvas id="chart-backtest"></canvas></div>
  </div>

  <div class="chart-grid" style="margin-bottom:24px;">
    <div class="chart-card">
      <h3>Backtest: Forward Sharpe by Drawdown Bucket</h3>
      <div class="chart-wrap"><canvas id="chart-sharpe-buckets"></canvas></div>
    </div>
    <div class="chart-card">
      <h3>Backtest: Forward Sharpe by NAV Momentum Bucket</h3>
      <div class="chart-wrap"><canvas id="chart-sharpe-momentum"></canvas></div>
    </div>
  </div>

  <!-- Backtest Results Table -->
  <div class="methodology" style="margin-bottom:24px;">
    <h3>Backtest Results: Entry Signal vs. Forward Performance</h3>
    <div id="backtest-table" style="overflow-x:auto;margin-top:12px;"></div>
    <p style="margin-top:12px;font-size:12px;color:var(--muted);" id="backtest-note">
      Forward periods are measured in data points (~hours for DB data, ~days for API data).
      Sharpe is annualized assuming ~365 periods/year for daily data. N = number of historical entry points in each bucket.
    </p>
  </div>

  <!-- Return Drivers -->
  <div id="return-drivers-section" style="display:none;">
    <div class="chart-card" style="margin-bottom:24px;">
      <h3>Return Drivers: PnL Attribution by Strategy</h3>
      <p style="font-size:12px;color:var(--muted);margin-bottom:16px;">
        HLP deploys capital across multiple sub-strategies. This chart decomposes cumulative PnL
        by strategy vault to show where returns originate.
      </p>
      <div class="chart-wrap" style="height:300px;"><canvas id="chart-pnl-attribution"></canvas></div>
    </div>

    <div class="chart-grid" style="margin-bottom:24px;">
      <div class="chart-card">
        <h3>Current Net Position Exposure</h3>
        <div id="position-exposure-table" style="overflow-x:auto;max-height:400px;overflow-y:auto;"></div>
      </div>
      <div class="chart-card">
        <h3>Cumulative Funding by Asset</h3>
        <div class="chart-wrap" style="height:300px;"><canvas id="chart-funding-breakdown"></canvas></div>
      </div>
    </div>
  </div>

  <!-- Calibrated Weights -->
  <div class="methodology" style="margin-bottom:24px;">
    <div id="calibrated-weights"></div>
  </div>

  <!-- Methodology -->
  <div class="methodology">
    <h3>Signal Framework Methodology</h3>
    <p>The composite score (0-100) aggregates seven independent signals, each scored 0-100 where higher = more edge for a new deposit. The signals are weighted by predictive importance:</p>
    <ul>
      <li><strong>Drawdown from ATH (25%):</strong> Deeper drawdowns in a positive-EV strategy = cheaper entry. Scored exponentially: 0% DD=0, 2%=30, 5%=65, 9%+=95.</li>
      <li><strong>TVL Momentum (15%):</strong> Falling TVL means fewer depositors competing for the same MM edge. Measured as % change over the trailing window. Negative TVL change = higher score.</li>
      <li><strong>Return Momentum (15%):</strong> After a streak of negative days, mean reversion favors new entrants. Measured by the ratio of negative to positive days in the recent window.</li>
      <li><strong>Volatility Regime (15%):</strong> High realized vol that is starting to decline = best entry. The vault's edge accrues in calmer regimes after drawdowns caused by vol spikes.</li>
      <li><strong>APR Relative Value (5%):</strong> Current APR vs. historical median. Below-median APR after a drawdown suggests the headline yield hasn't yet recovered, meaning less competition from yield-chasing inflows.</li>
      <li><strong>Funding Rate (15%):</strong> OI-weighted average funding across all HL perps. High positive funding means leveraged longs are paying shorts — HLP collects as counterparty. Negative funding = less fee accrual.</li>
      <li><strong>Open Interest Trend (10%):</strong> 7-day change in exchange-wide open interest. Surging OI = more flow and fee opportunities for HLP. Collapsing OI = fewer traders and less revenue.</li>
    </ul>
    <p style="margin-top:12px;"><strong>Interpretation:</strong> 0-25 = No Edge (wait). 25-50 = Low Edge (neutral). 50-70 = Moderate Edge (consider). 70-85 = Strong Edge (favorable). 85-100 = Max Edge (rare, post-crash).</p>
    <p style="margin-top:12px;"><strong>Forward Estimates:</strong> Using backtest data, we show the historical median forward return when entering at the current drawdown level. This is based on bucketed analysis of all historical entry points.</p>
    <p style="margin-top:8px;"><strong>Kelly Criterion:</strong> Position sizing computed from backtest win rate and payoff ratio at the current drawdown bucket. We use half-Kelly (standard safety margin) clamped to 0-50% of drawdown tolerance.</p>
    <p style="margin-top:8px;"><strong>Weight Calibration:</strong> Signal weights are calibrated by measuring the Sharpe spread (best-bucket minus worst-bucket) per signal dimension from backtest results. Signals with higher predictive power get more weight.</p>
    <p style="margin-top:8px;">Based on the Chaos Labs "Yield as a Risk Signal: Part II" framework. This is not financial advice. MM vaults are risk assets — size to drawdown.</p>
  </div>
</div>

<script>
const HLP_VAULT = '0xdfc24b077bc1425ad1dea75bcb6f8158e10df303';
const API_URL = 'https://api.hyperliquid.xyz/info';

let currentDataSource = 'api'; // 'db' or 'api'
let currentRange = 'all';
let chartInstances = {};
let refreshInterval = null;

// ── Data Source: Direct Hyperliquid API ─────────────────────
async function fetchVaultDetails() {
  const resp = await fetch(API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ type: 'vaultDetails', vaultAddress: HLP_VAULT })
  });
  if (!resp.ok) throw new Error(`API error: ${resp.status}`);
  return resp.json();
}

// ── Data Source: DB API ─────────────────────────────────────
async function fetchDBSnapshots(range) {
  const resp = await fetch(`/api/snapshots?range=${range}`);
  if (!resp.ok) throw new Error(`DB API error: ${resp.status}`);
  return resp.json();
}

async function fetchDBLatest() {
  const resp = await fetch('/api/latest');
  if (!resp.ok) throw new Error(`DB Latest API error: ${resp.status}`);
  return resp.json();
}

// ── Market Context: HL exchange-wide funding, OI, volume ─────
async function fetchMarketContextFrontend() {
  const resp = await fetch(API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ type: 'metaAndAssetCtxs' })
  });
  if (!resp.ok) throw new Error(`Market context API error: ${resp.status}`);
  const [meta, assetCtxs] = await resp.json();

  let totalOI = 0, totalVolume = 0, weightedFunding = 0, totalOIForWeighting = 0;
  for (const ctx of assetCtxs) {
    const oi = parseFloat(ctx.openInterest || 0);
    const vol = parseFloat(ctx.dayNtlVlm || 0);
    const funding = parseFloat(ctx.funding || 0);
    totalOI += oi;
    totalVolume += vol;
    if (oi > 0) { weightedFunding += funding * oi; totalOIForWeighting += oi; }
  }
  const fundingRate = totalOIForWeighting > 0 ? weightedFunding / totalOIForWeighting : 0;
  return { fundingRate, totalOI, volume24h: totalVolume };
}

// ── Return Drivers: Child Vault PnL, Positions, Funding ─────
async function fetchReturnDrivers(parentData) {
  const childAddresses = parentData?.relationship?.data?.childAddresses || [];
  if (childAddresses.length === 0) return null;

  // Fetch vaultDetails + clearinghouseState for all children in parallel
  const [childDetails, states] = await Promise.all([
    Promise.all(
      childAddresses.map(addr =>
        fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'vaultDetails', vaultAddress: addr })
        }).then(r => r.ok ? r.json() : null).catch(() => null)
      )
    ),
    Promise.all(
      childAddresses.map(addr =>
        fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'clearinghouseState', user: addr })
        }).then(r => r.ok ? r.json() : null).catch(() => null)
      )
    )
  ]);

  // Classify vaults
  const vaults = childAddresses.map((addr, i) => {
    const details = childDetails[i];
    const state = states[i];
    const positions = state?.assetPositions || [];
    const accountValue = parseFloat(state?.marginSummary?.accountValue || 0);
    const portfolio = details?.portfolio ? Object.fromEntries(details.portfolio) : {};
    const allTime = portfolio['allTime'];
    const pnlHistory = allTime?.pnlHistory?.map(([ts, val]) => ({
      time: ts, value: parseFloat(val)
    })) || [];
    return { addr, positions, accountValue, pnlHistory, name: details?.name || addr.slice(0, 10) };
  });

  const active = vaults.filter(v => v.positions.length > 0);
  const others = vaults.filter(v => v.positions.length === 0 && v.pnlHistory.length > 0);

  // Build net positions across all active strategy vaults
  const positionMap = new Map();
  for (const vault of active) {
    for (const ap of vault.positions) {
      const p = ap.position;
      const coin = p.coin;
      if (!positionMap.has(coin)) {
        positionMap.set(coin, { coin, netSize: 0, netNotional: 0, netUnrealizedPnl: 0, netFunding: 0, grossNotional: 0 });
      }
      const entry = positionMap.get(coin);
      const szi = parseFloat(p.szi);
      const posVal = parseFloat(p.positionValue);
      entry.netSize += szi;
      entry.netUnrealizedPnl += parseFloat(p.unrealizedPnl);
      entry.netFunding += parseFloat(p.cumFunding?.sinceOpen || 0);
      entry.grossNotional += Math.abs(posVal);
    }
  }

  return { vaults, active, others, positionMap };
}

// ── Compute analytics from DB snapshots ─────────────────────
function computeAnalyticsFromDB(snapshots, liveData) {
  if (!snapshots || snapshots.length === 0) throw new Error('No DB snapshots');

  // Build nav history from snapshots
  const navHistory = snapshots.map(s => ({
    time: new Date(s.collected_at).getTime(),
    value: parseFloat(s.nav)
  })).filter(d => d.value > 0);

  // Derive cumulative PnL from NAV changes (avoids mixing incompatible timeframe PnL values)
  const baseNav = navHistory.length > 0 ? navHistory[0].value : 0;
  const pnlHistory = navHistory.map(d => ({
    time: d.time,
    value: d.value - baseNav
  }));

  const currentNav = liveData ? liveData.nav : navHistory[navHistory.length - 1]?.value || 0;
  const currentPnl = liveData ? liveData.pnl : pnlHistory[pnlHistory.length - 1]?.value || 0;

  // ATH and drawdown history
  let ath = 0;
  const drawdownHistory = [];
  for (const point of navHistory) {
    if (point.value > ath) ath = point.value;
    const dd = (point.value - ath) / ath;
    drawdownHistory.push({ time: point.time, value: dd });
  }
  if (liveData && liveData.ath > ath) ath = liveData.ath;
  const currentDrawdown = ath > 0 ? (currentNav - ath) / ath : 0;

  let maxDD = 0;
  for (const d of drawdownHistory) {
    if (d.value < maxDD) maxDD = d.value;
  }

  // Aggregate to one NAV per calendar day (last value wins) to avoid
  // zig-zag from mixed-granularity sources (DeFiLlama daily + HL sub-hourly)
  const dailyMap = new Map();
  for (const d of navHistory) {
    const day = new Date(d.time).toISOString().slice(0, 10);
    dailyMap.set(day, d); // last value per day
  }
  const dailyNavArr = [...dailyMap.values()].sort((a, b) => a.time - b.time);

  // Compute daily returns from deduplicated daily NAV
  const dailyReturns = [];
  for (let i = 1; i < dailyNavArr.length; i++) {
    const ret = (dailyNavArr[i].value - dailyNavArr[i - 1].value) / dailyNavArr[i - 1].value;
    dailyReturns.push({
      time: dailyNavArr[i].time,
      day: new Date(dailyNavArr[i].time).toISOString().slice(0, 10),
      value: ret
    });
  }

  const dailyNavs = dailyNavArr.map(d => ({
    day: new Date(d.time).toISOString().slice(0, 10),
    value: d.value,
    time: d.time
  }));

  const recent30 = dailyReturns.slice(-30);
  const recent7 = dailyReturns.slice(-7);

  const threshold = 0.0002;
  const positiveDays = recent30.filter(d => d.value > threshold).length;
  const negativeDays = recent30.filter(d => d.value < -threshold).length;
  const flatDays = recent30.length - positiveDays - negativeDays;
  const hitRate = recent30.length > 0 ? positiveDays / recent30.length : 0;

  const avgDailyReturn = recent30.length > 0
    ? recent30.reduce((s, d) => s + d.value, 0) / recent30.length : 0;

  const variance = recent30.length > 1
    ? recent30.reduce((s, d) => s + Math.pow(d.value - avgDailyReturn, 2), 0) / (recent30.length - 1) : 0;
  const dailyVol = Math.sqrt(variance);

  const annualizedReturn = avgDailyReturn * 365;
  const annualizedVol = dailyVol * Math.sqrt(365);
  const sharpe = annualizedVol > 0 ? annualizedReturn / annualizedVol : 0;

  // Rolling 7-period
  const rollingWindow = 7;
  const rolling7 = [];
  for (let i = rollingWindow; i < dailyReturns.length; i++) {
    const w = dailyReturns.slice(i - rollingWindow, i);
    const mean = w.reduce((s, d) => s + d.value, 0) / w.length;
    const vol = Math.sqrt(w.reduce((s, d) => s + Math.pow(d.value - mean, 2), 0) / Math.max(1, w.length - 1));
    rolling7.push({
      time: dailyReturns[i].time,
      return7d: mean * rollingWindow,
      vol7d: vol
    });
  }

  // TVL change
  const nav7dAgo = navHistory.length > 7 ? navHistory[Math.max(0, navHistory.length - 8)].value : currentNav;
  const nav30dAgo = navHistory.length > 1 ? navHistory[0].value : currentNav;
  const tvlChange7d = nav7dAgo > 0 ? (currentNav - nav7dAgo) / nav7dAgo : 0;
  const tvlChange30d = nav30dAgo > 0 ? (currentNav - nav30dAgo) / nav30dAgo : 0;

  // Vol trend
  const last7Vol = rolling7.length > 0 ? rolling7[rolling7.length - 1].vol7d : 0;
  const midIdx = Math.max(0, rolling7.length - Math.floor(rolling7.length / 2));
  const prior7Vol = rolling7.length > 2 ? rolling7[midIdx].vol7d : last7Vol;
  const volTrend = prior7Vol > 0 ? (last7Vol - prior7Vol) / prior7Vol : 0;

  const lastApr = snapshots[snapshots.length - 1]?.apr;
  const currentApr = liveData ? liveData.apr : (lastApr != null ? parseFloat(lastApr) : 0);

  // Extract market context from latest snapshots
  const latestSnap = snapshots[snapshots.length - 1];
  const fundingRate = latestSnap?.funding_rate != null ? parseFloat(latestSnap.funding_rate) : 0;
  const totalOI = latestSnap?.open_interest != null ? parseFloat(latestSnap.open_interest) : 0;
  const volume24h = latestSnap?.volume_24h != null ? parseFloat(latestSnap.volume_24h) : 0;

  // OI change 7d
  const snapsWithOI = snapshots.filter(s => s.open_interest != null && parseFloat(s.open_interest) > 0);
  let oiChange7d = 0;
  if (snapsWithOI.length >= 2) {
    const latestOIVal = parseFloat(snapsWithOI[snapsWithOI.length - 1].open_interest);
    const sevenDaysAgoTime = Date.now() - 7 * 24 * 3600 * 1000;
    const snap7dOI = snapsWithOI.filter(s => new Date(s.collected_at).getTime() >= sevenDaysAgoTime);
    const oiAgo = snap7dOI.length > 0 ? parseFloat(snap7dOI[0].open_interest) : latestOIVal;
    if (oiAgo > 0) oiChange7d = (latestOIVal - oiAgo) / oiAgo;
  }

  return {
    navHistory, pnlHistory, drawdownHistory, dailyReturns, rolling7, dailyNavs,
    currentNav, currentPnl, ath, currentDrawdown, maxDD,
    positiveDays, negativeDays, flatDays, hitRate,
    avgDailyReturn, dailyVol, sharpe, annualizedReturn,
    tvlChange7d, tvlChange30d,
    last7Vol, prior7Vol, volTrend,
    currentApr,
    recent30, recent7,
    maxDistributable: liveData ? liveData.maxDistributable : 0,
    allowDeposits: liveData ? liveData.allowDeposits : true,
    fundingRate, totalOI, volume24h, oiChange7d
  };
}

// ── Compute Analytics (from direct API — original logic) ────
function computeAnalytics(data) {
  const portfolioMap = Object.fromEntries(data.portfolio);
  const allTime = portfolioMap['allTime'];
  const month = portfolioMap['month'];
  const week = portfolioMap['week'];

  if (!allTime) throw new Error('No allTime portfolio data');

  const navHistory = allTime.accountValueHistory.map(([ts, val]) => ({
    time: ts, value: parseFloat(val)
  })).filter(d => d.value > 0);

  const pnlHistory = allTime.pnlHistory.map(([ts, val]) => ({
    time: ts, value: parseFloat(val)
  })).filter(d => d.time > navHistory[0]?.time || 0);

  const monthNav = month ? month.accountValueHistory.map(([ts, val]) => ({
    time: ts, value: parseFloat(val)
  })).filter(d => d.value > 0) : [];

  const weekNav = week ? week.accountValueHistory.map(([ts, val]) => ({
    time: ts, value: parseFloat(val)
  })).filter(d => d.value > 0) : [];

  const currentNav = navHistory[navHistory.length - 1]?.value || 0;
  const currentPnl = pnlHistory[pnlHistory.length - 1]?.value || 0;

  let ath = 0;
  const drawdownHistory = [];
  for (const point of navHistory) {
    if (point.value > ath) ath = point.value;
    const dd = (point.value - ath) / ath;
    drawdownHistory.push({ time: point.time, value: dd });
  }
  const currentDrawdown = (currentNav - ath) / ath;

  let maxDD = 0;
  for (const d of drawdownHistory) {
    if (d.value < maxDD) maxDD = d.value;
  }

  const periodReturns = [];
  for (let i = 1; i < monthNav.length; i++) {
    const ret = (monthNav[i].value - monthNav[i - 1].value) / monthNav[i - 1].value;
    const dtHours = (monthNav[i].time - monthNav[i - 1].time) / (1000 * 60 * 60);
    periodReturns.push({
      time: monthNav[i].time,
      day: new Date(monthNav[i].time).toISOString().slice(0, 10),
      value: ret,
      dtHours
    });
  }

  const weekReturns = [];
  for (let i = 1; i < weekNav.length; i++) {
    const ret = (weekNav[i].value - weekNav[i - 1].value) / weekNav[i - 1].value;
    weekReturns.push({ time: weekNav[i].time, value: ret });
  }

  const dailyReturns = periodReturns;
  const dailyNavs = monthNav.map(d => ({ day: new Date(d.time).toISOString().slice(0, 10), value: d.value, time: d.time }));

  const recent30 = dailyReturns.slice(-30);
  const recent7 = dailyReturns.slice(-7);

  const threshold = 0.0002;
  const positiveDays = recent30.filter(d => d.value > threshold).length;
  const negativeDays = recent30.filter(d => d.value < -threshold).length;
  const flatDays = recent30.length - positiveDays - negativeDays;
  const hitRate = recent30.length > 0 ? positiveDays / recent30.length : 0;

  const avgDailyReturn = recent30.length > 0
    ? recent30.reduce((s, d) => s + d.value, 0) / recent30.length : 0;

  const variance = recent30.length > 1
    ? recent30.reduce((s, d) => s + Math.pow(d.value - avgDailyReturn, 2), 0) / (recent30.length - 1) : 0;
  const dailyVol = Math.sqrt(variance);

  const annualizedReturn = avgDailyReturn * 365;
  const annualizedVol = dailyVol * Math.sqrt(365);
  const sharpe = annualizedVol > 0 ? annualizedReturn / annualizedVol : 0;

  const rollingSource = weekReturns.length >= 14 ? weekReturns : dailyReturns;
  const rollingWindow = weekReturns.length >= 14 ? 14 : 7;
  const rolling7 = [];
  for (let i = rollingWindow; i < rollingSource.length; i++) {
    const w = rollingSource.slice(i - rollingWindow, i);
    const mean = w.reduce((s, d) => s + d.value, 0) / w.length;
    const vol = Math.sqrt(w.reduce((s, d) => s + Math.pow(d.value - mean, 2), 0) / Math.max(1, w.length - 1));
    rolling7.push({
      time: rollingSource[i].time,
      return7d: mean * rollingWindow,
      vol7d: vol
    });
  }

  const nav7dAgo = monthNav.length > 7 ? monthNav[Math.max(0, monthNav.length - 8)].value : currentNav;
  const nav30dAgo = monthNav.length > 1 ? monthNav[0].value : currentNav;
  const tvlChange7d = nav7dAgo > 0 ? (currentNav - nav7dAgo) / nav7dAgo : 0;
  const tvlChange30d = nav30dAgo > 0 ? (currentNav - nav30dAgo) / nav30dAgo : 0;

  const last7Vol = rolling7.length > 0 ? rolling7[rolling7.length - 1].vol7d : 0;
  const midIdx = Math.max(0, rolling7.length - Math.floor(rolling7.length / 2));
  const prior7Vol = rolling7.length > 2 ? rolling7[midIdx].vol7d : last7Vol;
  const volTrend = prior7Vol > 0 ? (last7Vol - prior7Vol) / prior7Vol : 0;

  const currentApr = data.apr || 0;

  return {
    navHistory, pnlHistory, drawdownHistory, dailyReturns, rolling7, dailyNavs,
    currentNav, currentPnl, ath, currentDrawdown, maxDD,
    positiveDays, negativeDays, flatDays, hitRate,
    avgDailyReturn, dailyVol, sharpe, annualizedReturn,
    tvlChange7d, tvlChange30d,
    last7Vol, prior7Vol, volTrend,
    currentApr,
    recent30, recent7,
    maxDistributable: data.maxDistributable || 0,
    allowDeposits: data.allowDeposits
  };
}

// ── Signal Scoring ──────────────────────────────────────────
function computeSignals(a) {
  const signals = {};

  const ddPct = Math.abs(a.currentDrawdown) * 100;
  let ddScore;
  if (ddPct < 0.1) ddScore = 5;
  else if (ddPct < 0.5) ddScore = 15;
  else if (ddPct < 1) ddScore = 25;
  else if (ddPct < 2) ddScore = 40;
  else if (ddPct < 3) ddScore = 55;
  else if (ddPct < 5) ddScore = 70;
  else if (ddPct < 7) ddScore = 85;
  else if (ddPct < 9) ddScore = 92;
  else ddScore = 98;

  signals.drawdown = {
    score: ddScore, weight: 0.25,
    label: 'Drawdown from ATH',
    detail: `${(a.currentDrawdown * 100).toFixed(2)}% from ATH ($${formatNum(a.ath)})`,
    explanation: ddPct < 1
      ? 'NAV is near ATH. No drawdown discount — you are entering at peak pricing.'
      : ddPct < 3
      ? 'Modest drawdown. Some discount to ATH but not a distressed entry.'
      : ddPct < 6
      ? 'Meaningful drawdown. Historically this level has offered good entries as the house edge grinds back.'
      : 'Large drawdown. If caused by market vol (not structural exploit), this is historically high-edge entry territory.'
  };

  const tvl7 = a.tvlChange7d * 100;
  let tvlScore;
  if (tvl7 > 3) tvlScore = 10;
  else if (tvl7 > 1) tvlScore = 25;
  else if (tvl7 > 0) tvlScore = 40;
  else if (tvl7 > -1) tvlScore = 55;
  else if (tvl7 > -3) tvlScore = 70;
  else if (tvl7 > -5) tvlScore = 85;
  else tvlScore = 95;

  signals.tvl = {
    score: tvlScore, weight: 0.15,
    label: 'TVL Momentum',
    detail: `7d: ${tvl7 >= 0 ? '+' : ''}${tvl7.toFixed(2)}% | 30d: ${(a.tvlChange30d * 100) >= 0 ? '+' : ''}${(a.tvlChange30d * 100).toFixed(2)}%`,
    explanation: tvl7 > 1
      ? 'TVL is growing — more capital competing for the same edge. Per-dollar returns compress.'
      : tvl7 > -1
      ? 'TVL roughly stable. Neutral signal.'
      : 'TVL declining — depositors leaving means higher edge per remaining dollar. Favorable for new entrants.'
  };

  const negRatio = a.recent30.length > 0 ? a.negativeDays / a.recent30.length : 0;
  const recent7Avg = a.recent7.length > 0
    ? a.recent7.reduce((s, d) => s + d.value, 0) / a.recent7.length : 0;
  let retScore;
  if (recent7Avg > 0.003) retScore = 10;
  else if (recent7Avg > 0.001) retScore = 25;
  else if (recent7Avg > 0) retScore = 40;
  else if (recent7Avg > -0.001) retScore = 55;
  else if (recent7Avg > -0.003) retScore = 70;
  else if (recent7Avg > -0.01) retScore = 85;
  else retScore = 95;

  signals.momentum = {
    score: retScore, weight: 0.15,
    label: 'Return Momentum',
    detail: `7d avg daily: ${(recent7Avg * 100).toFixed(3)}% | 30d hit rate: ${(a.hitRate * 100).toFixed(0)}% (${a.positiveDays}+/${a.negativeDays}-)`,
    explanation: recent7Avg > 0.001
      ? 'Recent returns are strong. Entering after a positive streak means less drawdown buffer.'
      : recent7Avg > -0.001
      ? 'Mixed/flat recent returns. Neutral entry conditions.'
      : 'Recent returns are negative. Mean-reversion dynamics favor recovery from here, good entry timing.'
  };

  const vol7dAnnualized = a.last7Vol * Math.sqrt(365) * 100;
  let volScore;
  if (a.volTrend < -0.3 && vol7dAnnualized > 10) volScore = 90;
  else if (a.volTrend < -0.1) volScore = 70;
  else if (Math.abs(a.volTrend) < 0.1) volScore = 50;
  else if (a.volTrend < 0.3) volScore = 35;
  else volScore = 15;

  signals.volatility = {
    score: volScore, weight: 0.15,
    label: 'Volatility Regime',
    detail: `7d ann. vol: ${vol7dAnnualized.toFixed(1)}% | Trend: ${a.volTrend > 0 ? '+' : ''}${(a.volTrend * 100).toFixed(0)}%`,
    explanation: a.volTrend < -0.1
      ? 'Volatility is declining from elevated levels. The vault\'s MM edge accrues best as vol normalizes post-shock.'
      : Math.abs(a.volTrend) < 0.1
      ? 'Volatility is stable. Neutral for entry timing.'
      : 'Volatility is rising. Drawdowns may deepen before recovery. Consider waiting for vol to peak.'
  };

  const aprPct = a.currentApr * 100;
  let aprScore;
  if (aprPct > 40) aprScore = 15;
  else if (aprPct > 25) aprScore = 30;
  else if (aprPct > 15) aprScore = 50;
  else if (aprPct > 8) aprScore = 65;
  else if (aprPct > 3) aprScore = 75;
  else aprScore = 90;

  signals.apr = {
    score: aprScore, weight: 0.05,
    label: 'APR Relative Value',
    detail: `Current APR: ${aprPct.toFixed(1)}%`,
    explanation: aprPct > 25
      ? 'High headline APR attracts deposits, compressing future edge. May be entering a crowding phase.'
      : aprPct > 10
      ? 'Moderate APR. Balanced between attraction and available edge.'
      : 'Low APR — fewer yield-chasers entering. Contrarian entry: APR tends to mean-revert upward after drawdowns.'
  };

  // 6. Funding Rate (15%)
  const fundingBps = (a.fundingRate || 0) * 10000;
  let fundingScore;
  if (fundingBps > 5) fundingScore = 90;
  else if (fundingBps > 2) fundingScore = 75;
  else if (fundingBps > 0.5) fundingScore = 60;
  else if (fundingBps > -0.5) fundingScore = 45;
  else if (fundingBps > -2) fundingScore = 25;
  else fundingScore = 15;

  signals.funding = {
    score: fundingScore, weight: 0.15,
    label: 'Funding Rate',
    detail: `OI-wtd avg: ${fundingBps.toFixed(2)} bps/8h`,
    explanation: fundingBps > 2
      ? 'High positive funding — leveraged longs paying shorts. HLP collects as counterparty. Favorable.'
      : fundingBps > -0.5
      ? 'Funding near neutral. Balanced positioning across the exchange.'
      : 'Negative funding — shorts dominating. Less fee accrual for HLP as counterparty.'
  };

  // 7. Open Interest Trend (10%)
  const oiChange = (a.oiChange7d || 0) * 100;
  let oiScore;
  if (oiChange > 10) oiScore = 90;
  else if (oiChange > 3) oiScore = 70;
  else if (oiChange > -3) oiScore = 50;
  else if (oiChange > -5) oiScore = 30;
  else oiScore = 15;

  signals.oi = {
    score: oiScore, weight: 0.10,
    label: 'Open Interest Trend',
    detail: `7d OI change: ${oiChange >= 0 ? '+' : ''}${oiChange.toFixed(1)}% | Total OI: $${formatNum(a.totalOI || 0)}`,
    explanation: oiChange > 3
      ? 'Open interest surging — more flow through the exchange means more counterparty activity for HLP.'
      : oiChange > -3
      ? 'Open interest stable. Neutral signal for HLP fee generation.'
      : 'Open interest collapsing — fewer traders means less flow and fee income for HLP.'
  };

  let composite = 0;
  for (const s of Object.values(signals)) {
    composite += s.score * s.weight;
  }
  composite = Math.round(composite);

  return { signals, composite };
}

// ── Forward Estimates ────────────────────────────────────────
function getForwardEstimate(backtest, analytics) {
  if (!backtest || backtest.totalPoints < 10) return null;
  const ddPct = Math.abs(analytics.currentDrawdown) * 100;
  const { ddBucketResults, forwardPeriods } = backtest;

  // Find which DD bucket current drawdown falls into
  let matchedBucket = null;
  for (const b of ddBucketResults) {
    const minPct = Math.abs(b.min) * 100;
    const maxPct = Math.abs(b.max) * 100;
    if (ddPct >= maxPct && ddPct < minPct) { matchedBucket = b; break; }
    if (ddPct >= Math.abs(b.max) * 100 && ddPct <= Math.abs(b.min) * 100) { matchedBucket = b; break; }
  }
  // Fallback: find bucket by raw drawdown value
  if (!matchedBucket) {
    const rawDD = analytics.currentDrawdown; // negative
    for (const b of ddBucketResults) {
      if (rawDD >= b.min && rawDD < b.max) { matchedBucket = b; break; }
    }
  }
  if (!matchedBucket) matchedBucket = ddBucketResults[0];

  // Use 10-period horizon (index 2) or last available
  const horizon = forwardPeriods.includes(10) ? 10 : forwardPeriods[forwardPeriods.length - 1];
  const stats = matchedBucket.stats[horizon];
  if (!stats || stats.n < 3) return null;

  return {
    bucket: matchedBucket.label,
    horizon,
    median: stats.median,
    mean: stats.mean,
    sharpe: stats.sharpe,
    n: stats.n
  };
}

// ── Weight Calibration ──────────────────────────────────────
function calibrateWeights(backtest) {
  if (!backtest || backtest.totalPoints < 50) return { sufficient: false, weights: null };

  const { ddBucketResults, momBucketResults } = backtest;
  const horizon = 10;

  // Compute Sharpe spread per dimension
  function sharpeSpread(buckets) {
    const sharpes = buckets.map(b => b.stats[horizon]?.sharpe || 0).filter(v => !isNaN(v));
    if (sharpes.length < 2) return 0;
    return Math.max(...sharpes) - Math.min(...sharpes);
  }

  const spreads = {
    drawdown: sharpeSpread(ddBucketResults),
    tvl: 0.3,       // default spread for signals without backtest buckets
    momentum: sharpeSpread(momBucketResults),
    volatility: 0.2,
    apr: 0.1,
    funding: 0.25,
    oi: 0.15
  };

  const totalSpread = Object.values(spreads).reduce((s, v) => s + Math.abs(v), 0);
  if (totalSpread === 0) return { sufficient: false, weights: null };

  const calibrated = {};
  for (const [key, spread] of Object.entries(spreads)) {
    calibrated[key] = Math.abs(spread) / totalSpread;
  }

  return { sufficient: true, weights: calibrated };
}

// ── Kelly Criterion ─────────────────────────────────────────
function computeKelly(backtest, analytics) {
  if (!backtest || backtest.totalPoints < 20) return null;

  const ddPct = Math.abs(analytics.currentDrawdown) * 100;
  const rawDD = analytics.currentDrawdown;
  const { ddBucketResults, forwardPeriods } = backtest;

  // Find current DD bucket
  let matchedBucket = null;
  for (const b of ddBucketResults) {
    if (rawDD >= b.min && rawDD < b.max) { matchedBucket = b; break; }
  }
  if (!matchedBucket) matchedBucket = ddBucketResults[0];

  const horizon = forwardPeriods.includes(10) ? 10 : forwardPeriods[forwardPeriods.length - 1];
  const stats = matchedBucket.stats[horizon];
  if (!stats || stats.n < 5) return null;

  // Use rawForwards if available, otherwise derive from stats
  const rawFwds = matchedBucket.rawForwards?.[horizon];
  let wins, losses;
  if (rawFwds && rawFwds.length > 0) {
    wins = rawFwds.filter(r => r > 0);
    losses = rawFwds.filter(r => r <= 0);
  } else {
    // Approximate from mean/std
    const p = stats.mean > 0 ? 0.6 : 0.4;
    const avgWin = Math.abs(stats.mean) + stats.std * 0.5;
    const avgLoss = Math.max(0.001, stats.std * 0.5 - (stats.mean > 0 ? 0 : Math.abs(stats.mean)));
    const b = avgWin / Math.max(0.001, avgLoss);
    const q = 1 - p;
    const kellyFull = (p * b - q) / Math.max(0.001, b);
    const halfKelly = Math.max(0, Math.min(0.5, kellyFull / 2));
    return { kelly: halfKelly, winRate: p, avgWin, avgLoss, odds: b, n: stats.n, bucket: matchedBucket.label };
  }

  if (wins.length === 0) return { kelly: 0, winRate: 0, avgWin: 0, avgLoss: 0, odds: 0, n: stats.n, bucket: matchedBucket.label };

  const p = wins.length / (wins.length + losses.length);
  const avgWin = wins.reduce((s, v) => s + v, 0) / wins.length;
  const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((s, v) => s + v, 0) / losses.length) : 0.001;
  const b = avgWin / Math.max(0.001, avgLoss);
  const q = 1 - p;
  const kellyFull = (p * b - q) / Math.max(0.001, b);
  const halfKelly = Math.max(0, Math.min(0.5, kellyFull / 2));

  return { kelly: halfKelly, winRate: p, avgWin, avgLoss, odds: b, n: stats.n, bucket: matchedBucket.label };
}

// ── Rendering ───────────────────────────────────────────────
function getScoreColor(score) {
  if (score >= 70) return 'var(--green)';
  if (score >= 50) return 'var(--yellow)';
  if (score >= 30) return 'var(--muted)';
  return 'var(--red)';
}

function getScoreClass(score) {
  if (score >= 70) return 'positive';
  if (score >= 50) return 'neutral';
  return 'negative';
}

function getVerdict(score) {
  if (score >= 85) return { title: 'MAX EDGE — Rare Post-Crash Entry', text: 'Multiple signals align for a high-conviction entry. Deep drawdown + falling TVL + negative momentum suggest maximum edge for new deposits. <strong>Size to drawdown tolerance, not to conviction.</strong>' };
  if (score >= 70) return { title: 'STRONG EDGE — Favorable Entry', text: 'Conditions favor new deposits. The vault is below ATH with supportive dynamics. <strong>Good time to deploy risk capital if you have a multi-month horizon.</strong>' };
  if (score >= 50) return { title: 'MODERATE EDGE — Consider Entry', text: 'Mixed signals. Some indicators favor entry but others are neutral or negative. <strong>Reasonable to start building a position, but not a screaming buy.</strong>' };
  if (score >= 30) return { title: 'LOW EDGE — Neutral', text: 'Few signals support a new deposit right now. The vault may be near ATH with growing TVL, compressing edge. <strong>No rush to enter. Wait for a drawdown.</strong>' };
  return { title: 'NO EDGE — Wait', text: 'Conditions are unfavorable. NAV is at or near ATH, TVL is growing, and yield chasers are crowding in. <strong>New deposits face compressed returns and elevated risk of being the exit liquidity.</strong>' };
}

function formatNum(n) {
  if (Math.abs(n) >= 1e9) return (n / 1e9).toFixed(2) + 'B';
  if (Math.abs(n) >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  if (Math.abs(n) >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toFixed(2);
}

function updateDataSourceIndicator(source) {
  const el = document.getElementById('data-source');
  if (source === 'db') {
    el.className = 'data-source db';
    el.innerHTML = '<span class="live-dot blue"></span> DB';
    document.getElementById('range-selector').style.display = 'flex';
  } else {
    el.className = 'data-source api';
    el.innerHTML = '<span class="live-dot green"></span> Direct API';
    document.getElementById('range-selector').style.display = 'none';
  }
}

function renderDashboard(data, analytics, signalResult, backtest) {
  const { signals, composite } = signalResult;

  document.getElementById('loading').style.display = 'none';
  document.getElementById('dashboard').style.display = 'block';
  document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleString()}`;

  // Composite gauge
  const gaugeCircle = document.getElementById('gauge-circle');
  const circumference = 2 * Math.PI * 60;
  const offset = circumference - (composite / 100) * circumference;
  gaugeCircle.style.strokeDashoffset = offset;
  gaugeCircle.style.stroke = getScoreColor(composite);

  const scoreEl = document.getElementById('composite-score');
  scoreEl.textContent = composite;
  scoreEl.style.color = getScoreColor(composite);

  const verdict = getVerdict(composite);
  document.getElementById('verdict-title').textContent = verdict.title;

  // Append forward estimate and Kelly to verdict
  let verdictExtra = '';
  const fwdEst = getForwardEstimate(backtest, analytics);
  const kelly = computeKelly(backtest, analytics);
  if (fwdEst) {
    const retSign = fwdEst.median >= 0 ? '+' : '';
    verdictExtra += ` Entering at this drawdown level (${fwdEst.bucket} DD) historically produced <strong>${retSign}${(fwdEst.median * 100).toFixed(2)}%</strong> median return over ${fwdEst.horizon} periods (n=${fwdEst.n}).`;
  }
  if (kelly && kelly.kelly > 0) {
    verdictExtra += ` Kelly criterion suggests sizing to <strong>${(kelly.kelly * 100).toFixed(0)}%</strong> of your drawdown tolerance.`;
  }
  document.getElementById('verdict-text').innerHTML = verdict.text + verdictExtra;

  // Signal bars
  const barsContainer = document.getElementById('signal-bars');
  barsContainer.innerHTML = '';
  for (const [key, sig] of Object.entries(signals)) {
    const row = document.createElement('div');
    row.className = 'signal-bar-row';
    row.innerHTML = `
      <span class="signal-bar-label">${sig.label} (${(sig.weight * 100).toFixed(0)}%)</span>
      <div class="signal-bar-track">
        <div class="signal-bar-fill" style="width:${sig.score}%;background:${getScoreColor(sig.score)}"></div>
      </div>
      <span class="signal-bar-value" style="color:${getScoreColor(sig.score)}">${sig.score}</span>
    `;
    barsContainer.appendChild(row);
  }

  // Metrics row
  const metricsRow = document.getElementById('metrics-row');
  const metrics = [
    { label: 'Current NAV', value: `$${formatNum(analytics.currentNav)}`, sub: `ATH: $${formatNum(analytics.ath)}` },
    { label: 'Drawdown', value: `${(analytics.currentDrawdown * 100).toFixed(2)}%`, sub: `Max DD: ${(analytics.maxDD * 100).toFixed(2)}%`, cls: analytics.currentDrawdown < -0.01 ? 'negative' : 'positive' },
    { label: 'APR', value: `${(analytics.currentApr * 100).toFixed(1)}%`, sub: `Sharpe: ${analytics.sharpe.toFixed(2)}` },
    { label: 'Avg Daily Return', value: `${(analytics.avgDailyReturn * 100).toFixed(3)}%`, sub: `Ann: ${(analytics.annualizedReturn * 100).toFixed(1)}%`, cls: analytics.avgDailyReturn > 0 ? 'positive' : 'negative' },
    { label: '30d Hit Rate', value: `${(analytics.hitRate * 100).toFixed(0)}%`, sub: `${analytics.positiveDays}+ / ${analytics.negativeDays}- / ${analytics.flatDays} flat`, cls: analytics.hitRate > 0.6 ? 'positive' : 'negative' },
    { label: 'Daily Volatility', value: `${(analytics.dailyVol * 100).toFixed(3)}%`, sub: `Ann: ${(analytics.dailyVol * Math.sqrt(365) * 100).toFixed(1)}%` },
    { label: 'All-Time PnL', value: `$${formatNum(analytics.currentPnl)}`, sub: '', cls: analytics.currentPnl > 0 ? 'positive' : 'negative' },
    { label: 'Deposits', value: analytics.allowDeposits ? 'OPEN' : 'CLOSED', sub: `TVL: $${formatNum(analytics.maxDistributable)}`, cls: analytics.allowDeposits ? 'positive' : 'negative' },
  ];

  // Add forward estimate metric
  if (fwdEst) {
    const retSign = fwdEst.median >= 0 ? '+' : '';
    metrics.push({
      label: 'Expected Forward Return',
      value: `${retSign}${(fwdEst.median * 100).toFixed(2)}%`,
      sub: `${fwdEst.bucket} DD bucket | ${fwdEst.horizon}p horizon | n=${fwdEst.n}`,
      cls: fwdEst.median > 0 ? 'positive' : 'negative'
    });
  }

  // Add Kelly metric
  if (kelly && kelly.kelly > 0) {
    metrics.push({
      label: 'Kelly Position Size',
      value: `${(kelly.kelly * 100).toFixed(0)}%`,
      sub: `Half-Kelly | Win: ${(kelly.winRate * 100).toFixed(0)}%, b=${kelly.odds.toFixed(2)} (n=${kelly.n})`,
      cls: 'positive'
    });
  }

  metricsRow.innerHTML = metrics.map(m => `
    <div class="metric-card">
      <div class="metric-label">${m.label}</div>
      <div class="metric-value ${m.cls || ''}">${m.value}</div>
      <div class="metric-sub">${m.sub}</div>
    </div>
  `).join('');

  // Signal detail cards
  const signalCards = document.getElementById('signal-cards');
  signalCards.innerHTML = '';
  for (const [key, sig] of Object.entries(signals)) {
    const card = document.createElement('div');
    card.className = 'signal-card';
    card.innerHTML = `
      <div class="signal-card-header">
        <span class="signal-card-title">${sig.label}</span>
        <span class="signal-card-score" style="color:${getScoreColor(sig.score)}">${sig.score}</span>
      </div>
      <div class="value-line">${sig.detail}</div>
      <p>${sig.explanation}</p>
    `;
    signalCards.appendChild(card);
  }

  // Calibrated weights
  const calibration = calibrateWeights(backtest);
  const calibDiv = document.getElementById('calibrated-weights');
  if (calibDiv && calibration.sufficient) {
    const defaultWeights = { drawdown: 0.25, tvl: 0.15, momentum: 0.15, volatility: 0.15, apr: 0.05, funding: 0.15, oi: 0.10 };
    const labels = { drawdown: 'Drawdown', tvl: 'TVL Momentum', momentum: 'Return Momentum', volatility: 'Volatility', apr: 'APR Value', funding: 'Funding Rate', oi: 'OI Trend' };
    let tableRows = '';
    for (const key of Object.keys(defaultWeights)) {
      const def = defaultWeights[key];
      const cal = calibration.weights[key] || 0;
      const delta = cal - def;
      const deltaStr = delta >= 0 ? `+${(delta * 100).toFixed(1)}` : (delta * 100).toFixed(1);
      const deltaClass = delta > 0.02 ? 'positive' : delta < -0.02 ? 'negative' : '';
      tableRows += `<tr style="border-bottom:1px solid rgba(30,41,59,0.3);">
        <td style="padding:6px 8px;">${labels[key]}</td>
        <td style="text-align:center;padding:6px 8px;">${(def * 100).toFixed(0)}%</td>
        <td style="text-align:center;padding:6px 8px;">${(cal * 100).toFixed(1)}%</td>
        <td style="text-align:center;padding:6px 8px;" class="${deltaClass}">${deltaStr}%</td>
      </tr>`;
    }
    calibDiv.innerHTML = `
      <h3 style="font-size:14px;font-weight:600;margin-bottom:12px;">Signal Weight Calibration (Sharpe-Spread Based)</h3>
      <table style="width:100%;border-collapse:collapse;font-size:12px;">
        <thead><tr style="border-bottom:1px solid var(--border);">
          <th style="text-align:left;padding:8px;color:var(--muted);">Signal</th>
          <th style="text-align:center;padding:8px;color:var(--muted);">Default</th>
          <th style="text-align:center;padding:8px;color:var(--muted);">Calibrated</th>
          <th style="text-align:center;padding:8px;color:var(--muted);">Delta</th>
        </tr></thead>
        <tbody>${tableRows}</tbody>
      </table>
      <p style="margin-top:8px;font-size:11px;color:var(--muted);">Calibrated from backtest Sharpe spreads across ${backtest.totalPoints} data points.</p>
    `;
  } else if (calibDiv) {
    calibDiv.innerHTML = '<p style="font-size:12px;color:var(--muted);">Insufficient data for weight calibration (need 50+ backtest points).</p>';
  }

  // Charts
  renderCharts(analytics);
}

// ── Charts ──────────────────────────────────────────────────
const chartDefaults = {
  responsive: true,
  maintainAspectRatio: false,
  animation: { duration: 800 },
  plugins: {
    legend: { display: false },
    tooltip: {
      backgroundColor: '#1e293b',
      titleColor: '#e2e8f0',
      bodyColor: '#94a3b8',
      borderColor: '#334155',
      borderWidth: 1,
      cornerRadius: 6,
      padding: 10,
      titleFont: { family: 'inherit', size: 12 },
      bodyFont: { family: 'inherit', size: 11 },
    }
  },
  scales: {
    x: {
      type: 'time',
      grid: { color: 'rgba(30,41,59,0.5)', drawBorder: false },
      ticks: { color: '#64748b', font: { size: 10, family: 'inherit' }, maxTicksLimit: 8 }
    },
    y: {
      grid: { color: 'rgba(30,41,59,0.5)', drawBorder: false },
      ticks: { color: '#64748b', font: { size: 10, family: 'inherit' } }
    }
  }
};

function destroyCharts() {
  for (const key of Object.keys(chartInstances)) {
    if (chartInstances[key]) {
      chartInstances[key].destroy();
      delete chartInstances[key];
    }
  }
}

function renderCharts(a) {
  destroyCharts();

  const sampleRate = Math.max(1, Math.floor(a.navHistory.length / 500));
  const sampledNav = a.navHistory.filter((_, i) => i % sampleRate === 0 || i === a.navHistory.length - 1);
  const sampledDD = a.drawdownHistory.filter((_, i) => i % sampleRate === 0 || i === a.drawdownHistory.length - 1);

  // 1. NAV + Drawdown Chart
  chartInstances.nav = new Chart(document.getElementById('chart-nav'), {
    type: 'line',
    data: {
      datasets: [
        {
          label: 'NAV',
          data: sampledNav.map(d => ({ x: d.time, y: d.value })),
          borderColor: '#3b82f6',
          backgroundColor: 'rgba(59,130,246,0.1)',
          fill: true,
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.1,
          yAxisID: 'y'
        },
        {
          label: 'Drawdown %',
          data: sampledDD.map(d => ({ x: d.time, y: d.value * 100 })),
          borderColor: '#ef4444',
          backgroundColor: 'rgba(239,68,68,0.08)',
          fill: true,
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.1,
          yAxisID: 'y1'
        }
      ]
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 16 } }
      },
      scales: {
        ...chartDefaults.scales,
        y: {
          ...chartDefaults.scales.y,
          position: 'left',
          ticks: {
            ...chartDefaults.scales.y.ticks,
            callback: v => '$' + formatNum(v)
          }
        },
        y1: {
          position: 'right',
          grid: { display: false },
          ticks: { color: '#ef4444', font: { size: 10, family: 'inherit' }, callback: v => v.toFixed(1) + '%' },
          max: 0,
        }
      }
    }
  });

  // 2. Daily Returns Distribution (fine-grained)
  const allReturns = a.dailyReturns;
  const bins = {};
  const retValues = allReturns.map(d => d.value * 100);
  const retRange = retValues.length > 0 ? Math.max(...retValues) - Math.min(...retValues) : 1;
  // Target ~30-40 bins for more granularity; floor to nice increments (0.01, 0.02, 0.05, 0.1...)
  const rawBin = retRange / 35;
  const niceSteps = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0];
  const binSize = niceSteps.find(s => s >= rawBin) || Math.max(0.05, Math.round(rawBin * 100) / 100);
  const decimals = binSize < 0.1 ? 2 : 1;
  for (const d of allReturns) {
    const bin = Math.round((d.value * 100) / binSize) * binSize;
    const key = bin.toFixed(decimals);
    bins[key] = (bins[key] || 0) + 1;
  }
  const sortedKeys = Object.keys(bins).sort((a, b) => parseFloat(a) - parseFloat(b));

  // Compute stats for annotation
  const retMean = retValues.length > 0 ? retValues.reduce((s, v) => s + v, 0) / retValues.length : 0;
  const retStd = retValues.length > 1
    ? Math.sqrt(retValues.reduce((s, v) => s + Math.pow(v - retMean, 2), 0) / (retValues.length - 1)) : 0;

  chartInstances.returns = new Chart(document.getElementById('chart-returns'), {
    type: 'bar',
    data: {
      labels: sortedKeys.map(k => k + '%'),
      datasets: [{
        label: 'Periods',
        data: sortedKeys.map(k => bins[k]),
        backgroundColor: sortedKeys.map(k => parseFloat(k) >= 0 ? 'rgba(34,197,94,0.5)' : 'rgba(239,68,68,0.5)'),
        borderColor: sortedKeys.map(k => parseFloat(k) >= 0 ? '#22c55e' : '#ef4444'),
        borderWidth: 1,
        borderRadius: 1,
        barPercentage: 1.0,
        categoryPercentage: 0.95,
      }]
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        subtitle: {
          display: true,
          text: `\u03bc=${retMean.toFixed(3)}%  \u03c3=${retStd.toFixed(3)}%  n=${retValues.length}`,
          color: '#64748b',
          font: { size: 10, family: 'inherit' },
          padding: { bottom: 8 }
        }
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            color: '#64748b',
            font: { size: 8, family: 'inherit' },
            maxRotation: 60,
            autoSkip: true,
            maxTicksLimit: 20,
          }
        },
        y: {
          ...chartDefaults.scales.y,
          ticks: { ...chartDefaults.scales.y.ticks, stepSize: 1 },
          title: { display: true, text: 'Periods', color: '#475569', font: { size: 10, family: 'inherit' } }
        }
      }
    }
  });

  // 3. Cumulative PnL
  const sampledPnl = a.pnlHistory.filter((_, i) => i % sampleRate === 0 || i === a.pnlHistory.length - 1);

  chartInstances.pnl = new Chart(document.getElementById('chart-pnl'), {
    type: 'line',
    data: {
      datasets: [{
        label: 'Cumulative PnL',
        data: sampledPnl.map(d => ({ x: d.time, y: d.value })),
        borderColor: '#22c55e',
        backgroundColor: 'rgba(34,197,94,0.1)',
        fill: true,
        borderWidth: 1.5,
        pointRadius: 0,
        tension: 0.1,
      }]
    },
    options: {
      ...chartDefaults,
      scales: {
        ...chartDefaults.scales,
        y: {
          ...chartDefaults.scales.y,
          ticks: { ...chartDefaults.scales.y.ticks, callback: v => '$' + formatNum(v) }
        }
      }
    }
  });

  // 4. Rolling return and vol
  const sampledRolling = a.rolling7.length > 300
    ? a.rolling7.filter((_, i) => i % Math.max(1, Math.floor(a.rolling7.length / 300)) === 0)
    : a.rolling7;

  chartInstances.rolling = new Chart(document.getElementById('chart-rolling'), {
    type: 'line',
    data: {
      datasets: [
        {
          label: '7d Return',
          data: sampledRolling.map(d => ({ x: d.time, y: d.return7d * 100 })),
          borderColor: '#3b82f6',
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.2,
          yAxisID: 'y'
        },
        {
          label: '7d Vol',
          data: sampledRolling.map(d => ({ x: d.time, y: d.vol7d * 100 })),
          borderColor: '#a855f7',
          backgroundColor: 'rgba(168,85,247,0.08)',
          fill: true,
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.2,
          yAxisID: 'y1'
        }
      ]
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 16 } }
      },
      scales: {
        ...chartDefaults.scales,
        y: {
          ...chartDefaults.scales.y,
          position: 'left',
          ticks: { ...chartDefaults.scales.y.ticks, callback: v => v.toFixed(2) + '%' }
        },
        y1: {
          position: 'right',
          grid: { display: false },
          ticks: { color: '#a855f7', font: { size: 10, family: 'inherit' }, callback: v => v.toFixed(2) + '%' }
        }
      }
    }
  });
}

// ── Backtest Engine ─────────────────────────────────────────
function runBacktest(analytics) {
  // Filter to 2024+ — pre-2024 HLP TVL was too low for meaningful signals
  const cutoff2024 = new Date('2024-01-01').getTime();
  const nav = analytics.navHistory.filter(d => d.time >= cutoff2024);
  if (nav.length < 10) return null;

  let ath = 0;
  const points = nav.map(d => {
    if (d.value > ath) ath = d.value;
    return { ...d, drawdown: (d.value - ath) / ath, ath };
  });

  const returns = [];
  for (let i = 1; i < points.length; i++) {
    returns.push({
      ...points[i],
      periodReturn: (points[i].value - points[i - 1].value) / points[i - 1].value,
      dtMs: points[i].time - points[i - 1].time
    });
  }

  for (let i = 0; i < returns.length; i++) {
    if (i >= 3) {
      const startVal = points[i - 2].value;
      returns[i].momentum3 = (returns[i].value - startVal) / startVal;
    } else {
      returns[i].momentum3 = 0;
    }
  }

  const forwardPeriods = [3, 5, 10, 20];
  const backtestResults = [];

  for (let i = 0; i < returns.length; i++) {
    const entry = returns[i];
    const fwd = {};
    let valid = true;

    for (const h of forwardPeriods) {
      const exitIdx = i + h;
      if (exitIdx < points.length) {
        fwd[h] = (points[exitIdx].value - entry.value) / entry.value;
      } else {
        valid = false;
        break;
      }
    }

    if (valid) {
      backtestResults.push({
        time: entry.time,
        drawdown: entry.drawdown,
        momentum3: entry.momentum3,
        forward: fwd
      });
    }
  }

  const ddBuckets = [
    { label: '0-0.5%', min: -0.005, max: 0 },
    { label: '0.5-2%', min: -0.02, max: -0.005 },
    { label: '2-5%', min: -0.05, max: -0.02 },
    { label: '5-10%', min: -0.10, max: -0.05 },
    { label: '10%+', min: -1, max: -0.10 },
  ];

  const ddBucketResults = ddBuckets.map(bucket => {
    const entries = backtestResults.filter(r => r.drawdown >= bucket.min && r.drawdown < bucket.max);
    const stats = {};
    const rawForwards = {};
    for (const h of forwardPeriods) {
      const fwdReturns = entries.map(e => e.forward[h]).filter(v => v !== undefined);
      rawForwards[h] = fwdReturns;
      if (fwdReturns.length > 0) {
        const mean = fwdReturns.reduce((s, v) => s + v, 0) / fwdReturns.length;
        const variance = fwdReturns.length > 1
          ? fwdReturns.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (fwdReturns.length - 1) : 0;
        const std = Math.sqrt(variance);
        const sharpe = std > 0 ? (mean / std) * Math.sqrt(365 / Math.max(1, h)) : 0;
        stats[h] = { mean, std, sharpe, n: fwdReturns.length, median: sortedMedian(fwdReturns) };
      }
    }
    return { ...bucket, entries: entries.length, stats, rawForwards };
  });

  const momBuckets = [
    { label: 'Strong Up (>3%)', min: 0.03, max: 1 },
    { label: 'Up (1-3%)', min: 0.01, max: 0.03 },
    { label: 'Flat (-1% to 1%)', min: -0.01, max: 0.01 },
    { label: 'Down (-3 to -1%)', min: -0.03, max: -0.01 },
    { label: 'Strong Down (<-3%)', min: -1, max: -0.03 },
  ];

  const momBucketResults = momBuckets.map(bucket => {
    const entries = backtestResults.filter(r => r.momentum3 >= bucket.min && r.momentum3 < bucket.max);
    const stats = {};
    const rawForwards = {};
    for (const h of forwardPeriods) {
      const fwdReturns = entries.map(e => e.forward[h]).filter(v => v !== undefined);
      rawForwards[h] = fwdReturns;
      if (fwdReturns.length > 0) {
        const mean = fwdReturns.reduce((s, v) => s + v, 0) / fwdReturns.length;
        const variance = fwdReturns.length > 1
          ? fwdReturns.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (fwdReturns.length - 1) : 0;
        const std = Math.sqrt(variance);
        const sharpe = std > 0 ? (mean / std) * Math.sqrt(365 / Math.max(1, h)) : 0;
        stats[h] = { mean, std, sharpe, n: fwdReturns.length, median: sortedMedian(fwdReturns) };
      }
    }
    return { ...bucket, entries: entries.length, stats, rawForwards };
  });

  return { ddBucketResults, momBucketResults, forwardPeriods, totalPoints: backtestResults.length };
}

function sortedMedian(arr) {
  const sorted = [...arr].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function renderBacktest(backtest) {
  if (!backtest || backtest.totalPoints < 5) {
    document.getElementById('backtest-table').innerHTML = '<p style="color:var(--muted)">Insufficient historical data for backtest (need more data points).</p>';
    return;
  }

  const { ddBucketResults, momBucketResults, forwardPeriods } = backtest;

  const tableHtml = `
    <table style="width:100%;border-collapse:collapse;font-size:12px;">
      <thead>
        <tr style="border-bottom:1px solid var(--border);">
          <th style="text-align:left;padding:8px;color:var(--muted);">Entry Condition</th>
          <th style="text-align:center;padding:8px;color:var(--muted);">N</th>
          ${forwardPeriods.map(h => `
            <th style="text-align:center;padding:8px;color:var(--muted);">Fwd ${h}p Return</th>
            <th style="text-align:center;padding:8px;color:var(--muted);">Fwd ${h}p Sharpe</th>
          `).join('')}
        </tr>
      </thead>
      <tbody>
        <tr><td colspan="${2 + forwardPeriods.length * 2}" style="padding:12px 8px 4px;color:var(--text);font-weight:600;">By Drawdown at Entry</td></tr>
        ${ddBucketResults.map(b => `
          <tr style="border-bottom:1px solid rgba(30,41,59,0.3);">
            <td style="padding:6px 8px;">${b.label} DD</td>
            <td style="text-align:center;padding:6px 8px;color:var(--muted);">${b.entries}</td>
            ${forwardPeriods.map(h => {
              const s = b.stats[h];
              if (!s) return '<td style="text-align:center;padding:6px 8px;color:var(--muted);">-</td><td style="text-align:center;padding:6px 8px;color:var(--muted);">-</td>';
              const retClass = s.mean > 0 ? 'positive' : s.mean < 0 ? 'negative' : '';
              const sharpeClass = s.sharpe > 1 ? 'positive' : s.sharpe < 0 ? 'negative' : 'neutral';
              return `
                <td style="text-align:center;padding:6px 8px;" class="${retClass}">${(s.mean * 100).toFixed(2)}%</td>
                <td style="text-align:center;padding:6px 8px;" class="${sharpeClass}">${s.sharpe.toFixed(2)}</td>
              `;
            }).join('')}
          </tr>
        `).join('')}
        <tr><td colspan="${2 + forwardPeriods.length * 2}" style="padding:16px 8px 4px;color:var(--text);font-weight:600;">By Trailing 3-Period Momentum at Entry</td></tr>
        ${momBucketResults.map(b => `
          <tr style="border-bottom:1px solid rgba(30,41,59,0.3);">
            <td style="padding:6px 8px;">${b.label}</td>
            <td style="text-align:center;padding:6px 8px;color:var(--muted);">${b.entries}</td>
            ${forwardPeriods.map(h => {
              const s = b.stats[h];
              if (!s) return '<td style="text-align:center;padding:6px 8px;color:var(--muted);">-</td><td style="text-align:center;padding:6px 8px;color:var(--muted);">-</td>';
              const retClass = s.mean > 0 ? 'positive' : s.mean < 0 ? 'negative' : '';
              const sharpeClass = s.sharpe > 1 ? 'positive' : s.sharpe < 0 ? 'negative' : 'neutral';
              return `
                <td style="text-align:center;padding:6px 8px;" class="${retClass}">${(s.mean * 100).toFixed(2)}%</td>
                <td style="text-align:center;padding:6px 8px;" class="${sharpeClass}">${s.sharpe.toFixed(2)}</td>
              `;
            }).join('')}
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
  document.getElementById('backtest-table').innerHTML = tableHtml;

  // Forward Return by Drawdown Bar Chart
  const ddLabels = ddBucketResults.map(b => b.label);
  const horizon = forwardPeriods[forwardPeriods.length > 2 ? 2 : forwardPeriods.length - 1];
  const fwdReturnsByDD = ddBucketResults.map(b => b.stats[horizon]?.mean * 100 || 0);
  const fwdSharpeByDD = ddBucketResults.map(b => b.stats[horizon]?.sharpe || 0);

  chartInstances.backtest = new Chart(document.getElementById('chart-backtest'), {
    type: 'bar',
    data: {
      labels: ddLabels.map(l => l + ' DD'),
      datasets: [
        {
          label: `Avg Fwd ${horizon}-Period Return (%)`,
          data: fwdReturnsByDD,
          backgroundColor: fwdReturnsByDD.map(v => v >= 0 ? 'rgba(34,197,94,0.6)' : 'rgba(239,68,68,0.6)'),
          borderColor: fwdReturnsByDD.map(v => v >= 0 ? '#22c55e' : '#ef4444'),
          borderWidth: 1,
          borderRadius: 3,
          yAxisID: 'y'
        },
        {
          label: `Ann. Sharpe (${horizon}p fwd)`,
          data: fwdSharpeByDD,
          type: 'line',
          borderColor: '#a855f7',
          backgroundColor: 'rgba(168,85,247,0.2)',
          borderWidth: 2,
          pointRadius: 4,
          pointBackgroundColor: '#a855f7',
          tension: 0.3,
          yAxisID: 'y1'
        }
      ]
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 16 } }
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: { color: '#64748b', font: { size: 11, family: 'inherit' } }
        },
        y: {
          position: 'left',
          grid: { color: 'rgba(30,41,59,0.5)', drawBorder: false },
          ticks: { color: '#64748b', font: { size: 10, family: 'inherit' }, callback: v => v.toFixed(1) + '%' },
          title: { display: true, text: 'Forward Return %', color: '#475569', font: { size: 10, family: 'inherit' } }
        },
        y1: {
          position: 'right',
          grid: { display: false },
          ticks: { color: '#a855f7', font: { size: 10, family: 'inherit' } },
          title: { display: true, text: 'Sharpe', color: '#a855f7', font: { size: 10, family: 'inherit' } }
        }
      }
    }
  });

  // Sharpe by DD Bucket
  const colors = ['#3b82f6', '#22c55e', '#eab308', '#ef4444'];
  chartInstances.sharpeBuckets = new Chart(document.getElementById('chart-sharpe-buckets'), {
    type: 'bar',
    data: {
      labels: ddLabels,
      datasets: forwardPeriods.map((h, idx) => ({
        label: `${h}-period fwd`,
        data: ddBucketResults.map(b => b.stats[h]?.sharpe || 0),
        backgroundColor: colors[idx] + '99',
        borderColor: colors[idx],
        borderWidth: 1,
        borderRadius: 2,
      }))
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 12 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { color: '#64748b', font: { size: 10, family: 'inherit' } } },
        y: {
          ...chartDefaults.scales.y,
          title: { display: true, text: 'Annualized Sharpe', color: '#475569', font: { size: 10, family: 'inherit' } }
        }
      }
    }
  });

  // Sharpe by Momentum Bucket
  const momLabels = momBucketResults.map(b => b.label);
  chartInstances.sharpeMomentum = new Chart(document.getElementById('chart-sharpe-momentum'), {
    type: 'bar',
    data: {
      labels: momLabels,
      datasets: forwardPeriods.map((h, idx) => ({
        label: `${h}-period fwd`,
        data: momBucketResults.map(b => b.stats[h]?.sharpe || 0),
        backgroundColor: colors[idx] + '99',
        borderColor: colors[idx],
        borderWidth: 1,
        borderRadius: 2,
      }))
    },
    options: {
      ...chartDefaults,
      plugins: {
        ...chartDefaults.plugins,
        legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 12 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { color: '#64748b', font: { size: 10, family: 'inherit' }, maxRotation: 20 } },
        y: {
          ...chartDefaults.scales.y,
          title: { display: true, text: 'Annualized Sharpe', color: '#475569', font: { size: 10, family: 'inherit' } }
        }
      }
    }
  });
}

// ── Render Return Drivers ───────────────────────────────────
function renderReturnDrivers(drivers) {
  const section = document.getElementById('return-drivers-section');
  if (!drivers) { section.style.display = 'none'; return; }
  section.style.display = 'block';

  const { vaults, active, others, positionMap } = drivers;
  const cutoff2024 = new Date('2024-01-01').getTime();

  // ── PnL Attribution Chart (stacked area) ──
  // Group: combine active vaults as "Market Making", show others individually
  const mmPnl = [];
  if (active.length > 0) {
    // Merge pnlHistory from all active vaults by aligning timestamps
    const tsMap = new Map();
    for (const v of active) {
      for (const pt of v.pnlHistory) {
        if (pt.time < cutoff2024) continue;
        const existing = tsMap.get(pt.time) || 0;
        tsMap.set(pt.time, existing + pt.value);
      }
    }
    const sorted = [...tsMap.entries()].sort((a, b) => a[0] - b[0]);
    for (const [ts, val] of sorted) {
      mmPnl.push({ x: ts, y: val });
    }
  }

  const strategyColors = ['#3b82f6', '#22c55e', '#eab308', '#a855f7', '#06b6d4', '#f97316', '#ec4899'];
  const datasets = [];

  if (mmPnl.length > 0) {
    const sampleRate = Math.max(1, Math.floor(mmPnl.length / 400));
    datasets.push({
      label: 'Market Making (A+B)',
      data: mmPnl.filter((_, i) => i % sampleRate === 0 || i === mmPnl.length - 1),
      borderColor: strategyColors[0],
      backgroundColor: strategyColors[0] + '33',
      fill: true,
      borderWidth: 1.5,
      pointRadius: 0,
      tension: 0.2,
    });
  }

  others.forEach((v, idx) => {
    const filtered = v.pnlHistory.filter(pt => pt.time >= cutoff2024);
    if (filtered.length === 0) return;
    const sampleRate = Math.max(1, Math.floor(filtered.length / 400));
    const color = strategyColors[(idx + 1) % strategyColors.length];
    datasets.push({
      label: v.name,
      data: filtered.filter((_, i) => i % sampleRate === 0 || i === filtered.length - 1).map(pt => ({ x: pt.time, y: pt.value })),
      borderColor: color,
      backgroundColor: color + '33',
      fill: true,
      borderWidth: 1.5,
      pointRadius: 0,
      tension: 0.2,
    });
  });

  if (chartInstances.pnlAttribution) chartInstances.pnlAttribution.destroy();

  if (datasets.length > 0) {
    chartInstances.pnlAttribution = new Chart(document.getElementById('chart-pnl-attribution'), {
      type: 'line',
      data: { datasets },
      options: {
        ...chartDefaults,
        plugins: {
          ...chartDefaults.plugins,
          legend: { display: true, labels: { color: '#64748b', font: { size: 10, family: 'inherit' }, boxWidth: 12, padding: 12 } },
          tooltip: {
            ...chartDefaults.plugins.tooltip,
            mode: 'index',
            intersect: false,
            callbacks: {
              label: ctx => `${ctx.dataset.label}: $${formatNum(ctx.parsed.y)}`
            }
          }
        },
        interaction: { mode: 'index', intersect: false },
        scales: {
          ...chartDefaults.scales,
          y: {
            ...chartDefaults.scales.y,
            stacked: true,
            ticks: { ...chartDefaults.scales.y.ticks, callback: v => '$' + formatNum(v) }
          }
        }
      }
    });
  } else {
    document.getElementById('chart-pnl-attribution').parentElement.innerHTML =
      '<p style="color:var(--muted);text-align:center;padding:40px;">No historical PnL data available for child vaults.</p>';
  }

  // ── Position Exposure Table ──
  const tableContainer = document.getElementById('position-exposure-table');
  if (positionMap.size === 0) {
    tableContainer.innerHTML = '<p style="color:var(--muted);padding:20px;">No active positions.</p>';
  } else {
    const positions = [...positionMap.values()]
      .sort((a, b) => b.grossNotional - a.grossNotional)
      .slice(0, 15);

    let rows = '';
    for (const p of positions) {
      const direction = p.netSize > 0.0001 ? 'Long' : p.netSize < -0.0001 ? 'Short' : 'Neutral';
      const dirClass = direction === 'Long' ? 'positive' : direction === 'Short' ? 'negative' : '';
      const dirArrow = direction === 'Long' ? '&#9650;' : direction === 'Short' ? '&#9660;' : '&#9679;';
      const pnlClass = p.netUnrealizedPnl >= 0 ? 'positive' : 'negative';
      const fundClass = p.netFunding >= 0 ? 'positive' : 'negative';
      rows += `<tr style="border-bottom:1px solid rgba(30,41,59,0.3);">
        <td style="padding:6px 8px;font-weight:600;">${p.coin}</td>
        <td style="padding:6px 8px;text-align:center;" class="${dirClass}">${dirArrow} ${direction}</td>
        <td style="padding:6px 8px;text-align:right;">$${formatNum(p.grossNotional)}</td>
        <td style="padding:6px 8px;text-align:right;" class="${pnlClass}">${p.netUnrealizedPnl >= 0 ? '+' : ''}$${formatNum(p.netUnrealizedPnl)}</td>
        <td style="padding:6px 8px;text-align:right;" class="${fundClass}">${p.netFunding >= 0 ? '+' : ''}$${formatNum(p.netFunding)}</td>
      </tr>`;
    }

    tableContainer.innerHTML = `
      <table style="width:100%;border-collapse:collapse;font-size:12px;">
        <thead><tr style="border-bottom:1px solid var(--border);">
          <th style="text-align:left;padding:8px;color:var(--muted);">Coin</th>
          <th style="text-align:center;padding:8px;color:var(--muted);">Net Direction</th>
          <th style="text-align:right;padding:8px;color:var(--muted);">Gross Notional</th>
          <th style="text-align:right;padding:8px;color:var(--muted);">Unrealized PnL</th>
          <th style="text-align:right;padding:8px;color:var(--muted);">Cum Funding</th>
        </tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  // ── Funding Breakdown Chart (horizontal bar) ──
  if (chartInstances.fundingBreakdown) chartInstances.fundingBreakdown.destroy();

  if (positionMap.size > 0) {
    const fundingData = [...positionMap.values()]
      .filter(p => Math.abs(p.netFunding) > 0.01)
      .sort((a, b) => Math.abs(b.netFunding) - Math.abs(a.netFunding))
      .slice(0, 10);

    if (fundingData.length > 0) {
      chartInstances.fundingBreakdown = new Chart(document.getElementById('chart-funding-breakdown'), {
        type: 'bar',
        data: {
          labels: fundingData.map(p => p.coin),
          datasets: [{
            label: 'Net Cum. Funding ($)',
            data: fundingData.map(p => p.netFunding),
            backgroundColor: fundingData.map(p => p.netFunding >= 0 ? 'rgba(34,197,94,0.6)' : 'rgba(239,68,68,0.6)'),
            borderColor: fundingData.map(p => p.netFunding >= 0 ? '#22c55e' : '#ef4444'),
            borderWidth: 1,
            borderRadius: 3,
          }]
        },
        options: {
          ...chartDefaults,
          indexAxis: 'y',
          plugins: {
            ...chartDefaults.plugins,
            legend: { display: false },
            tooltip: {
              ...chartDefaults.plugins.tooltip,
              callbacks: {
                label: ctx => `Funding: ${ctx.parsed.x >= 0 ? '+' : ''}$${formatNum(ctx.parsed.x)}`
              }
            }
          },
          scales: {
            x: {
              grid: { color: 'rgba(30,41,59,0.5)', drawBorder: false },
              ticks: { color: '#64748b', font: { size: 10, family: 'inherit' }, callback: v => '$' + formatNum(v) }
            },
            y: {
              grid: { display: false },
              ticks: { color: '#e2e8f0', font: { size: 11, family: 'inherit' } }
            }
          }
        }
      });
    } else {
      document.getElementById('chart-funding-breakdown').parentElement.innerHTML =
        '<p style="color:var(--muted);text-align:center;padding:40px;">No significant funding accruals.</p>';
    }
  } else {
    document.getElementById('chart-funding-breakdown').parentElement.innerHTML =
      '<p style="color:var(--muted);text-align:center;padding:40px;">No active positions.</p>';
  }
}

// ── Init with DB fallback to direct API ─────────────────────
async function initFromDB(range) {
  const [snapshotData, latestData] = await Promise.all([
    fetchDBSnapshots(range),
    fetchDBLatest()
  ]);

  if (!snapshotData.snapshots || snapshotData.snapshots.length === 0) {
    throw new Error('No DB snapshots available');
  }

  currentDataSource = 'db';
  updateDataSourceIndicator('db');

  const liveData = latestData.live || null;
  const analytics = computeAnalyticsFromDB(snapshotData.snapshots, liveData);
  const signalResult = computeSignals(analytics);

  const backtest = runBacktest(analytics);
  renderDashboard(null, analytics, signalResult, backtest);
  renderBacktest(backtest);

  // Return drivers — fetch live child vault data regardless of DB mode
  fetchVaultDetails()
    .then(parentData => fetchReturnDrivers(parentData))
    .then(drivers => renderReturnDrivers(drivers))
    .catch(err => { console.warn('Return drivers unavailable:', err.message); renderReturnDrivers(null); });
}

async function initFromAPI() {
  const [data, marketCtx] = await Promise.all([
    fetchVaultDetails(),
    fetchMarketContextFrontend().catch(() => ({ fundingRate: 0, totalOI: 0, volume24h: 0 }))
  ]);
  const analytics = computeAnalytics(data);
  // Merge market context
  analytics.fundingRate = marketCtx.fundingRate;
  analytics.totalOI = marketCtx.totalOI;
  analytics.volume24h = marketCtx.volume24h;
  analytics.oiChange7d = 0; // no trailing data in API mode

  const signalResult = computeSignals(analytics);

  currentDataSource = 'api';
  updateDataSourceIndicator('api');

  const backtest = runBacktest(analytics);
  renderDashboard(data, analytics, signalResult, backtest);
  renderBacktest(backtest);

  // Return drivers — data already has parent vault details
  fetchReturnDrivers(data)
    .then(drivers => renderReturnDrivers(drivers))
    .catch(err => { console.warn('Return drivers unavailable:', err.message); renderReturnDrivers(null); });
}

async function init(range) {
  range = range || currentRange;
  currentRange = range;

  try {
    // Try DB first
    await initFromDB(range);
  } catch (dbErr) {
    console.warn('DB unavailable, falling back to direct API:', dbErr.message);
    try {
      await initFromAPI();
    } catch (apiErr) {
      document.getElementById('loading').innerHTML = `
        <div class="error-msg">Failed to load HLP data: ${apiErr.message}</div>
        <p style="color:var(--muted);font-size:13px;">Both the database API and direct Hyperliquid API are unavailable. Check console for details.</p>
      `;
      console.error('DB error:', dbErr);
      console.error('API error:', apiErr);
    }
  }
}

// ── Time Range Selector ─────────────────────────────────────
document.getElementById('range-selector').addEventListener('click', (e) => {
  const btn = e.target.closest('.range-btn');
  if (!btn) return;

  // Update active state
  document.querySelectorAll('.range-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');

  const range = btn.dataset.range;
  init(range);
});

// ── Auto-refresh every 5 minutes ────────────────────────────
refreshInterval = setInterval(() => init(), 5 * 60 * 1000);

// ── Start ───────────────────────────────────────────────────
init();
</script>
</body>
</html>
